{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\Ramil Christian\\\\Desktop\\\\RCA-Portfolio\\\\rca-portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"C:\\\\Users\\\\Ramil Christian\\\\Desktop\\\\RCA-Portfolio\\\\rca-portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport { resolveElements } from '../render/dom/utils/resolve-element.mjs';\nimport { visualElementStore } from '../render/store.mjs';\nimport { invariant } from '../utils/errors.mjs';\nimport { GroupPlaybackControls } from './GroupPlaybackControls.mjs';\nimport { isDOMKeyframes } from './utils/is-dom-keyframes.mjs';\nimport { animateTarget } from './interfaces/visual-element-target.mjs';\nimport { createVisualElement } from './utils/create-visual-element.mjs';\nimport { animateSingleValue } from './interfaces/single-value.mjs';\nimport { createAnimationsFromSequence } from './sequence/create.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n  var elements = resolveElements(elementOrSelector, scope);\n  var numElements = elements.length;\n  invariant(Boolean(numElements), \"No valid element provided.\");\n  var animations = [];\n  for (var i = 0; i < numElements; i++) {\n    var element = elements[i];\n    /**\n     * Check each element for an associated VisualElement. If none exists,\n     * we need to create one.\n     */\n    if (!visualElementStore.has(element)) {\n      /**\n       * TODO: We only need render-specific parts of the VisualElement.\n       * With some additional work the size of the animate() function\n       * could be reduced significantly.\n       */\n      createVisualElement(element);\n    }\n    var visualElement = visualElementStore.get(element);\n    var transition = _objectSpread({}, options);\n    /**\n     * Resolve stagger function if provided.\n     */\n    if (typeof transition.delay === \"function\") {\n      transition.delay = transition.delay(i, numElements);\n    }\n    animations.push.apply(animations, _toConsumableArray(animateTarget(visualElement, _objectSpread({}, keyframes, {\n      transition: transition\n    }), {})));\n  }\n  return new GroupPlaybackControls(animations);\n}\nvar isSequence = function isSequence(value) {\n  return Array.isArray(value) && Array.isArray(value[0]);\n};\nfunction animateSequence(sequence, options, scope) {\n  var animations = [];\n  var animationDefinitions = createAnimationsFromSequence(sequence, options, scope);\n  animationDefinitions.forEach(function (_ref, subject) {\n    var keyframes = _ref.keyframes,\n      transition = _ref.transition;\n    var animation;\n    if (isMotionValue(subject)) {\n      animation = animateSingleValue(subject, keyframes.default, transition.default);\n    } else {\n      animation = animateElements(subject, keyframes, transition);\n    }\n    animations.push(animation);\n  });\n  return new GroupPlaybackControls(animations);\n}\nvar createScopedAnimate = function createScopedAnimate(scope) {\n  /**\n   * Implementation\n   */\n  function scopedAnimate(valueOrElementOrSequence, keyframes, options) {\n    var animation;\n    if (isSequence(valueOrElementOrSequence)) {\n      animation = animateSequence(valueOrElementOrSequence, keyframes, scope);\n    } else if (isDOMKeyframes(keyframes)) {\n      animation = animateElements(valueOrElementOrSequence, keyframes, options, scope);\n    } else {\n      animation = animateSingleValue(valueOrElementOrSequence, keyframes, options);\n    }\n    if (scope) {\n      scope.animations.push(animation);\n    }\n    return animation;\n  }\n  return scopedAnimate;\n};\nvar animate = createScopedAnimate();\nexport { animate, createScopedAnimate };","map":null,"metadata":{},"sourceType":"module"}