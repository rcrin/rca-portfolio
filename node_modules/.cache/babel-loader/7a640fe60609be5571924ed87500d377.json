{"ast":null,"code":"import _objectWithoutProperties from \"C:\\\\Users\\\\Ramil Christian\\\\Desktop\\\\RCA-Portfolio\\\\rca-portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectWithoutProperties\";\nimport _objectSpread from \"C:\\\\Users\\\\Ramil Christian\\\\Desktop\\\\RCA-Portfolio\\\\rca-portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"C:\\\\Users\\\\Ramil Christian\\\\Desktop\\\\RCA-Portfolio\\\\rca-portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Ramil Christian\\\\Desktop\\\\RCA-Portfolio\\\\rca-portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { frame, cancelFrame } from '../frameloop/index.mjs';\nimport { warning, invariant } from '../utils/errors.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { isRefObject } from '../utils/is-ref-object.mjs';\nimport { initPrefersReducedMotion } from '../utils/reduced-motion/index.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from '../utils/reduced-motion/state.mjs';\nimport { SubscriptionManager } from '../utils/subscription-manager.mjs';\nimport { motionValue } from '../value/index.mjs';\nimport { isWillChangeMotionValue } from '../value/use-will-change/is.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\nimport { transformProps } from './html/utils/transform.mjs';\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\nimport { isVariantLabel } from './utils/is-variant-label.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\nimport { warnOnce } from '../utils/warn-once.mjs';\nimport { featureDefinitions } from '../motion/features/definitions.mjs';\nimport { variantProps } from './utils/variant-props.mjs';\nimport { visualElementStore } from './store.mjs';\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\nvar propEventHandlers = [\"AnimationStart\", \"AnimationComplete\", \"Update\", \"BeforeLayoutMeasure\", \"LayoutMeasure\", \"LayoutAnimationStart\", \"LayoutAnimationComplete\"];\nvar numVariantProps = variantProps.length;\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nvar VisualElement = /*#__PURE__*/function () {\n  function VisualElement(_ref) {\n    var _this = this;\n    var parent = _ref.parent,\n      props = _ref.props,\n      presenceContext = _ref.presenceContext,\n      reducedMotionConfig = _ref.reducedMotionConfig,\n      visualState = _ref.visualState;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, VisualElement);\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    this.current = null;\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n    this.children = new Set();\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    this.isVariantNode = false;\n    this.isControllingVariants = false;\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n    this.shouldReduceMotion = null;\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    this.values = new Map();\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n    this.features = {};\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    this.valueSubscriptions = new Map();\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    this.prevMotionValues = {};\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    this.events = {};\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n    this.propEventSubscriptions = {};\n    this.notifyUpdate = function () {\n      return _this.notify(\"Update\", _this.latestValues);\n    };\n    this.render = function () {\n      if (!_this.current) return;\n      _this.triggerBuild();\n      _this.renderInstance(_this.current, _this.renderState, _this.props.style, _this.projection);\n    };\n    this.scheduleRender = function () {\n      return frame.render(_this.render, false, true);\n    };\n    var latestValues = visualState.latestValues,\n      renderState = visualState.renderState;\n    this.latestValues = latestValues;\n    this.baseTarget = _objectSpread({}, latestValues);\n    this.initialValues = props.initial ? _objectSpread({}, latestValues) : {};\n    this.renderState = renderState;\n    this.parent = parent;\n    this.props = props;\n    this.presenceContext = presenceContext;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.reducedMotionConfig = reducedMotionConfig;\n    this.options = options;\n    this.isControllingVariants = isControllingVariants(props);\n    this.isVariantNode = isVariantNode(props);\n    if (this.isVariantNode) {\n      this.variantChildren = new Set();\n    }\n    this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n    /**\n     * Any motion values that are provided to the element when created\n     * aren't yet bound to the element, as this would technically be impure.\n     * However, we iterate through the motion values and set them to the\n     * initial values for this component.\n     *\n     * TODO: This is impure and we should look at changing this to run on mount.\n     * Doing so will break some tests but this isn't neccessarily a breaking change,\n     * more a reflection of the test.\n     */\n    var _this$scrapeMotionVal = this.scrapeMotionValuesFromProps(props, {}),\n      willChange = _this$scrapeMotionVal.willChange,\n      initialMotionValues = _objectWithoutProperties(_this$scrapeMotionVal, [\"willChange\"]);\n    for (var key in initialMotionValues) {\n      var value = initialMotionValues[key];\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n        if (isWillChangeMotionValue(willChange)) {\n          willChange.add(key);\n        }\n      }\n    }\n  }\n  /**\n   * This method takes React props and returns found MotionValues. For example, HTML\n   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n   *\n   * This isn't an abstract method as it needs calling in the constructor, but it is\n   * intended to be one.\n   */\n  _createClass(VisualElement, [{\n    key: \"scrapeMotionValuesFromProps\",\n    value: function scrapeMotionValuesFromProps(_props, _prevProps) {\n      return {};\n    }\n  }, {\n    key: \"mount\",\n    value: function mount(instance) {\n      var _this2 = this;\n      this.current = instance;\n      visualElementStore.set(instance, this);\n      if (this.projection && !this.projection.instance) {\n        this.projection.mount(instance);\n      }\n      if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n        this.removeFromVariantTree = this.parent.addVariantChild(this);\n      }\n      this.values.forEach(function (value, key) {\n        return _this2.bindToMotionValue(key, value);\n      });\n      if (!hasReducedMotionListener.current) {\n        initPrefersReducedMotion();\n      }\n      this.shouldReduceMotion = this.reducedMotionConfig === \"never\" ? false : this.reducedMotionConfig === \"always\" ? true : prefersReducedMotion.current;\n      if (process.env.NODE_ENV !== \"production\") {\n        warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n      }\n      if (this.parent) this.parent.children.add(this);\n      this.update(this.props, this.presenceContext);\n    }\n  }, {\n    key: \"unmount\",\n    value: function unmount() {\n      visualElementStore.delete(this.current);\n      this.projection && this.projection.unmount();\n      cancelFrame(this.notifyUpdate);\n      cancelFrame(this.render);\n      this.valueSubscriptions.forEach(function (remove) {\n        return remove();\n      });\n      this.removeFromVariantTree && this.removeFromVariantTree();\n      this.parent && this.parent.children.delete(this);\n      for (var key in this.events) {\n        this.events[key].clear();\n      }\n      for (var _key in this.features) {\n        this.features[_key].unmount();\n      }\n      this.current = null;\n    }\n  }, {\n    key: \"bindToMotionValue\",\n    value: function bindToMotionValue(key, value) {\n      var _this3 = this;\n      var valueIsTransform = transformProps.has(key);\n      var removeOnChange = value.on(\"change\", function (latestValue) {\n        _this3.latestValues[key] = latestValue;\n        _this3.props.onUpdate && frame.update(_this3.notifyUpdate, false, true);\n        if (valueIsTransform && _this3.projection) {\n          _this3.projection.isTransformDirty = true;\n        }\n      });\n      var removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\n      this.valueSubscriptions.set(key, function () {\n        removeOnChange();\n        removeOnRenderRequest();\n      });\n    }\n  }, {\n    key: \"sortNodePosition\",\n    value: function sortNodePosition(other) {\n      /**\n       * If these nodes aren't even of the same type we can't compare their depth.\n       */\n      if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {\n        return 0;\n      }\n      return this.sortInstanceNodePosition(this.current, other.current);\n    }\n  }, {\n    key: \"loadFeatures\",\n    value: function loadFeatures(_ref2, isStrict, preloadedFeatures, initialLayoutGroupConfig) {\n      var _this4 = this;\n      var children = _ref2.children,\n        renderedProps = _objectWithoutProperties(_ref2, [\"children\"]);\n      var ProjectionNodeConstructor;\n      var MeasureLayout;\n      /**\n       * If we're in development mode, check to make sure we're not rendering a motion component\n       * as a child of LazyMotion, as this will break the file-size benefits of using it.\n       */\n      if (process.env.NODE_ENV !== \"production\" && preloadedFeatures && isStrict) {\n        var strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n        renderedProps.ignoreStrict ? warning(false, strictMessage) : invariant(false, strictMessage);\n      }\n      for (var i = 0; i < numFeatures; i++) {\n        var name = featureNames[i];\n        var _featureDefinitions$n = featureDefinitions[name],\n          isEnabled = _featureDefinitions$n.isEnabled,\n          FeatureConstructor = _featureDefinitions$n.Feature,\n          ProjectionNode = _featureDefinitions$n.ProjectionNode,\n          MeasureLayoutComponent = _featureDefinitions$n.MeasureLayout;\n        if (ProjectionNode) ProjectionNodeConstructor = ProjectionNode;\n        if (isEnabled(renderedProps)) {\n          if (!this.features[name] && FeatureConstructor) {\n            this.features[name] = new FeatureConstructor(this);\n          }\n          if (MeasureLayoutComponent) {\n            MeasureLayout = MeasureLayoutComponent;\n          }\n        }\n      }\n      if (!this.projection && ProjectionNodeConstructor) {\n        this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);\n        var layoutId = renderedProps.layoutId,\n          layout = renderedProps.layout,\n          drag = renderedProps.drag,\n          dragConstraints = renderedProps.dragConstraints,\n          layoutScroll = renderedProps.layoutScroll,\n          layoutRoot = renderedProps.layoutRoot;\n        this.projection.setOptions({\n          layoutId: layoutId,\n          layout: layout,\n          alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),\n          visualElement: this,\n          scheduleRender: function scheduleRender() {\n            return _this4.scheduleRender();\n          },\n          /**\n           * TODO: Update options in an effect. This could be tricky as it'll be too late\n           * to update by the time layout animations run.\n           * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n           * ensuring it gets called if there's no potential layout animations.\n           *\n           */\n          animationType: typeof layout === \"string\" ? layout : \"both\",\n          initialPromotionConfig: initialLayoutGroupConfig,\n          layoutScroll: layoutScroll,\n          layoutRoot: layoutRoot\n        });\n      }\n      return MeasureLayout;\n    }\n  }, {\n    key: \"updateFeatures\",\n    value: function updateFeatures() {\n      for (var key in this.features) {\n        var feature = this.features[key];\n        if (feature.isMounted) {\n          feature.update();\n        } else {\n          feature.mount();\n          feature.isMounted = true;\n        }\n      }\n    }\n  }, {\n    key: \"triggerBuild\",\n    value: function triggerBuild() {\n      this.build(this.renderState, this.latestValues, this.options, this.props);\n    }\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n  }, {\n    key: \"measureViewportBox\",\n    value: function measureViewportBox() {\n      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n    }\n  }, {\n    key: \"getStaticValue\",\n    value: function getStaticValue(key) {\n      return this.latestValues[key];\n    }\n  }, {\n    key: \"setStaticValue\",\n    value: function setStaticValue(key, value) {\n      this.latestValues[key] = value;\n    }\n    /**\n     * Make a target animatable by Popmotion. For instance, if we're\n     * trying to animate width from 100px to 100vw we need to measure 100vw\n     * in pixels to determine what we really need to animate to. This is also\n     * pluggable to support Framer's custom value types like Color,\n     * and CSS variables.\n     */\n  }, {\n    key: \"makeTargetAnimatable\",\n    value: function makeTargetAnimatable(target) {\n      var canMutate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);\n    }\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n  }, {\n    key: \"update\",\n    value: function update(props, presenceContext) {\n      if (props.transformTemplate || this.props.transformTemplate) {\n        this.scheduleRender();\n      }\n      this.prevProps = this.props;\n      this.props = props;\n      this.prevPresenceContext = this.presenceContext;\n      this.presenceContext = presenceContext;\n      /**\n       * Update prop event handlers ie onAnimationStart, onAnimationComplete\n       */\n      for (var i = 0; i < propEventHandlers.length; i++) {\n        var key = propEventHandlers[i];\n        if (this.propEventSubscriptions[key]) {\n          this.propEventSubscriptions[key]();\n          delete this.propEventSubscriptions[key];\n        }\n        var listener = props[\"on\" + key];\n        if (listener) {\n          this.propEventSubscriptions[key] = this.on(key, listener);\n        }\n      }\n      this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues);\n      if (this.handleChildMotionValue) {\n        this.handleChildMotionValue();\n      }\n    }\n  }, {\n    key: \"getProps\",\n    value: function getProps() {\n      return this.props;\n    }\n    /**\n     * Returns the variant definition with a given name.\n     */\n  }, {\n    key: \"getVariant\",\n    value: function getVariant(name) {\n      return this.props.variants ? this.props.variants[name] : undefined;\n    }\n    /**\n     * Returns the defined default transition on this component.\n     */\n  }, {\n    key: \"getDefaultTransition\",\n    value: function getDefaultTransition() {\n      return this.props.transition;\n    }\n  }, {\n    key: \"getTransformPagePoint\",\n    value: function getTransformPagePoint() {\n      return this.props.transformPagePoint;\n    }\n  }, {\n    key: \"getClosestVariantNode\",\n    value: function getClosestVariantNode() {\n      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : undefined;\n    }\n  }, {\n    key: \"getVariantContext\",\n    value: function getVariantContext() {\n      var startAtParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (startAtParent) {\n        return this.parent ? this.parent.getVariantContext() : undefined;\n      }\n      if (!this.isControllingVariants) {\n        var _context = this.parent ? this.parent.getVariantContext() || {} : {};\n        if (this.props.initial !== undefined) {\n          _context.initial = this.props.initial;\n        }\n        return _context;\n      }\n      var context = {};\n      for (var i = 0; i < numVariantProps; i++) {\n        var name = variantProps[i];\n        var prop = this.props[name];\n        if (isVariantLabel(prop) || prop === false) {\n          context[name] = prop;\n        }\n      }\n      return context;\n    }\n    /**\n     * Add a child visual element to our set of children.\n     */\n  }, {\n    key: \"addVariantChild\",\n    value: function addVariantChild(child) {\n      var closestVariantNode = this.getClosestVariantNode();\n      if (closestVariantNode) {\n        closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);\n        return function () {\n          return closestVariantNode.variantChildren.delete(child);\n        };\n      }\n    }\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n  }, {\n    key: \"addValue\",\n    value: function addValue(key, value) {\n      // Remove existing value if it exists\n      if (value !== this.values.get(key)) {\n        this.removeValue(key);\n        this.bindToMotionValue(key, value);\n      }\n      this.values.set(key, value);\n      this.latestValues[key] = value.get();\n    }\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n  }, {\n    key: \"removeValue\",\n    value: function removeValue(key) {\n      this.values.delete(key);\n      var unsubscribe = this.valueSubscriptions.get(key);\n      if (unsubscribe) {\n        unsubscribe();\n        this.valueSubscriptions.delete(key);\n      }\n      delete this.latestValues[key];\n      this.removeValueFromRenderState(key, this.renderState);\n    }\n    /**\n     * Check whether we have a motion value for this key\n     */\n  }, {\n    key: \"hasValue\",\n    value: function hasValue(key) {\n      return this.values.has(key);\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue(key, defaultValue) {\n      if (this.props.values && this.props.values[key]) {\n        return this.props.values[key];\n      }\n      var value = this.values.get(key);\n      if (value === undefined && defaultValue !== undefined) {\n        value = motionValue(defaultValue, {\n          owner: this\n        });\n        this.addValue(key, value);\n      }\n      return value;\n    }\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n  }, {\n    key: \"readValue\",\n    value: function readValue(key) {\n      var _a;\n      return this.latestValues[key] !== undefined || !this.current ? this.latestValues[key] : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);\n    }\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n  }, {\n    key: \"setBaseTarget\",\n    value: function setBaseTarget(key, value) {\n      this.baseTarget[key] = value;\n    }\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n  }, {\n    key: \"getBaseTarget\",\n    value: function getBaseTarget(key) {\n      var _a;\n      var initial = this.props.initial;\n      var valueFromInitial = typeof initial === \"string\" || typeof initial === \"object\" ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key] : undefined;\n      /**\n       * If this value still exists in the current initial variant, read that.\n       */\n      if (initial && valueFromInitial !== undefined) {\n        return valueFromInitial;\n      }\n      /**\n       * Alternatively, if this VisualElement config has defined a getBaseTarget\n       * so we can read the value from an alternative source, try that.\n       */\n      var target = this.getBaseTargetFromProps(this.props, key);\n      if (target !== undefined && !isMotionValue(target)) return target;\n      /**\n       * If the value was initially defined on initial, but it doesn't any more,\n       * return undefined. Otherwise return the value as initially read from the DOM.\n       */\n      return this.initialValues[key] !== undefined && valueFromInitial === undefined ? undefined : this.baseTarget[key];\n    }\n  }, {\n    key: \"on\",\n    value: function on(eventName, callback) {\n      if (!this.events[eventName]) {\n        this.events[eventName] = new SubscriptionManager();\n      }\n      return this.events[eventName].add(callback);\n    }\n  }, {\n    key: \"notify\",\n    value: function notify(eventName) {\n      if (this.events[eventName]) {\n        var _this$events$eventNam;\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n        (_this$events$eventNam = this.events[eventName]).notify.apply(_this$events$eventNam, args);\n      }\n    }\n  }]);\n  return VisualElement;\n}();\nexport { VisualElement };","map":null,"metadata":{},"sourceType":"module"}